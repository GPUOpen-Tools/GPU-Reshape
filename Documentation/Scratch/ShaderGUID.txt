# Disorganized thoughts about instruction to source code mappings used at Ava, need to allow for bigger numbers...

Too much shader data
    Ava had small number of pipelines, some games have ... well, a lot.

Need a shader UID

Loc GUID is easy

keep in the command buffer

Race safe

-----------------------------------------
	full flush on
		descriptor
		pipeline

allocate more bits to the GUID

remove type?
	type local buffers

	type local, then each need breadcrumbs

	remove message restriction, very good

	buffer per type... n writes

	guid local per command buffer

		slap stick solution

-------

1. flush
    in some pathological cases, performance will TANK. goes against design

2. different buffers
	would save 6 bits, quite a lot

    breadcrumb writing, N times
	    only need that when the feature is active

	global
		wont have ALL features on at the same time

	need to bind multiple buffers and things... not too bad?
		64 max

		binding? have that problem anyway...

	traversal is a lot easier

	message API
		bit offsets support

		1:1 to frontend, no processing, that's a good win

	cyclic buffer
		eats its own tail

		do we want it cyclic?
			what do we gain? not much for the added complexity, just min it
				one frame address conflict, that's ok... maybe

		can have one large allocation still
			each command buffer have their own "space"

			do we even need that?

			yeah, how do we determine the start read?
			hmm

			true

			separate host buffers for types
				size can change

			do not write to the host directly, async transfer queue!! Big win (proof of concept does this, is amazing on PCIE gen 4).

			Yeah, it's heavily pipelined, but, that's ok, latency doesn't matter, maybe...

3. increase size
    booooo, boooo
