// Generated File

// Test defines
$DEFINES

// Test
#include <Test/Device/IDevice.h>
#include <Test/Device/Catch2.h>

// Backend
#include <Backend/IShaderSGUIDHost.h>
#include <Backend/Environment.h>
#include <Backend/EnvironmentInfo.h>
#include <Backend/FeatureHost.h>
#include <Backend/ShaderSGUIDHostListener.h>

// Bridge
#include <Bridge/IBridgeListener.h>
#include <Bridge/IBridge.h>

// Message
#include <Message/IMessageStorage.h>

// Devices
#ifdef ENABLE_BACKEND_VULKAN
#include <Test/Device/Vulkan/Device.h>
#endif // ENABLE_BACKEND_VULKAN
#ifdef ENABLE_BACKEND_DX12
#include <Test/Device/DX12/Device.h>
#endif // ENABLE_BACKEND_DX12

// Common
#include <Common/Registry.h>

// Std
#include <functional>

// Shared schemas
#include <Schemas/Config.h>
#include <Schemas/Instrumentation.h>
#include <Schemas/SGUID.h>

// Test includes
$INCLUDES

using namespace Test;

$CONSTRAINTS;

struct ShaderCode {
    const void* code{nullptr};
    uint32_t size{0};
};

template<typename DEVICE>
class $TEST_NAMERunner {
public:
    void Run(const ShaderCode& code) {
        Backend::EnvironmentInfo info;
        info.memoryBridge = true;
        environment.Install(info);

        // Get the shared registry
        Registry* registry = environment.GetRegistry();

        // Get common objects
        auto bridge = registry->Get<IBridge>();

        // Add sguid listener
        bridge->Register(ShaderSourceMappingMessage::kID, registry->AddNew<ShaderSGUIDHostListener>());

$CONSTRAINT_INSTALL

        Execute(code);
        Validate();
    }

private:
    void ConfigureBridge() {
        // Get common objects
        auto bridge = environment.GetRegistry()->Get<IBridge>();

        // Ordered stream
        MessageStream stream;
#ifdef _MSC_VER // Clang-cl bug, works fine for other tests
        MessageStreamView<void, MessageStream> view(stream);
#else
        MessageStreamView view(stream);
#endif
        // Make the recording wait for compilation
        auto config = view.Add<SetInstrumentationConfigMessage>();
        config->synchronousRecording = 1;

        // Global instrumentation
        auto msg = view.Add<SetGlobalInstrumentationMessage>();
        msg->featureBitSet = ~0ull;

        // Submit configuration
        bridge->GetOutput()->AddStream(stream);
        bridge->Commit();
    }

    void Execute(const ShaderCode& code) {
        Registry* registry = environment.GetRegistry();

        // Create a device
        auto device = registry->AddNew<DEVICE>();

        // Install the device
        Test::DeviceInfo info{};
        info.enableValidation = false;
        device->Install(info);

        // Optional, resource set
        ResourceSetID resourceSet;

        // All layouts
        std::vector<ResourceLayoutID> layouts;

        // Any resources?
        const bool hasResources = $HAS_RESOURCES;

        if (hasResources) {
            // Create all resources
$RESOURCES_CREATE

            // Types for layout definition
            ResourceType resourceTypes[] = {
$RESOURCES_TYPES
            };

            // Create layout
            ResourceLayoutID layout = device->CreateResourceLayout(resourceTypes, sizeof(resourceTypes) / sizeof(ResourceType));

            // Resources for set
            ResourceID resources[] = {
$RESOURCES_SET
            };

            // Create set
            resourceSet = device->CreateResourceSet(layout, resources, sizeof(resources) / sizeof(ResourceID));

            // Add layout
            layouts.push_back(layout);
        }

        // Create pipeline
        PipelineID pipeline = device->CreateComputePipeline(layouts.data(), layouts.size(), code.code, code.size);

        // Set the bridge up for the expected communication
        ConfigureBridge();

        // Create command buffer
        CommandBufferID commandBuffer = device->CreateCommandBuffer(QueueType::Graphics);

        // Begin!
        device->BeginCommandBuffer(commandBuffer);

        // Init all resources
        device->InitializeResources(commandBuffer);

        // Bind pipeline and resources
        device->BindPipeline(commandBuffer, pipeline);

        if (hasResources) {
            device->BindResourceSet(commandBuffer, resourceSet);
        }

$COMMANDS

        // End!
        device->EndCommandBuffer(commandBuffer);

        // Submit on generic graphics
        device->Submit(device->GetQueue(QueueType::Graphics), commandBuffer);
        device->Flush();
    }

    void Validate() {
$CONSTRAINT_VALIDATE
    }

private:
    Backend::Environment environment;

$CONSTRAINT_FIELDS
};

TEST_CASE("Features.$FEATURE_NAME.$TEST_NAME") {
#ifdef ENABLE_BACKEND_VULKAN
    SECTION("Vulkan") {
        $TEST_NAMERunner<Vulkan::Device>{}.Run(ShaderCode {
            .code = kShaderCodeVulkan,
            .size = sizeof(kShaderCodeVulkan)
        });
    }
#endif // ENABLE_BACKEND_VULKAN

#ifdef ENABLE_BACKEND_DX12
    SECTION("DX12") {
        $TEST_NAMERunner<DX12::Device>{}.Run(ShaderCode {
            .code = kShaderCodeD3D12,
            .size = sizeof(kShaderCodeD3D12)
        });
    }
#endif // ENABLE_BACKEND_DX12
}

