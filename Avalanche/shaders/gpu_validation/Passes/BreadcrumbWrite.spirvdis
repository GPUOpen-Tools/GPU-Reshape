; Written as native SPIRV due to HLSL incompatabilities ;

; CAPABILITY BLOCK ;
OpCapability Shader
OpCapability AtomicStorageOps
OpExtension "SPV_KHR_shader_atomic_counter_ops"
%std450 = OpExtInstImport "GLSL.std.450"
OpMemoryModel Logical GLSL450
OpEntryPoint GLCompute %main "main"
OpExecutionMode %main LocalSize 1 1 1

; DECORATION BLOCK ;
OpDecorate %var_DiagnosticData DescriptorSet 0 ; In accordance with the diagnostics allocator
OpDecorate %var_DiagnosticData Binding 0       ; In accordance with the diagnostics allocator
OpMemberDecorate %BreadcrumbWriteData 0 Offset 0
OpDecorate %BreadcrumbWriteData Block
OpDecorate %BreadcrumbBatch ArrayStride 4
OpDecorate %MessageRArrayType ArrayStride 4
OpMemberDecorate %DiagnosticData 0 Offset 0  ; Message count starts at 0
OpMemberDecorate %DiagnosticData 1 Offset 4  ; Message limit starts at 4
OpMemberDecorate %DiagnosticData 2 Offset 16 ; Message data starts at 16
OpDecorate %DiagnosticData Block

; COMMON BLOCK ;
%uint = OpTypeInt 32 0
%int = OpTypeInt 32 1
%bool = OpTypeBool
%void = OpTypeVoid

; BATCH PROPERTIES ;
%constant_BatchSize = OpConstant %uint 4

; TYPE BLOCK ;
%StorageBufferUintPtr = OpTypePointer StorageBuffer %uint
%PushConstantUintPtr = OpTypePointer PushConstant %uint
%FunctionUintPtr = OpTypePointer Function %uint
%BreadcrumbBatch = OpTypeArray %uint %constant_BatchSize
%BreadcrumbWriteData = OpTypeStruct %BreadcrumbBatch
%BreadcrumbWriteDataPtr = OpTypePointer PushConstant %BreadcrumbWriteData
%MessageRArrayType = OpTypeRuntimeArray %uint
%DiagnosticData = OpTypeStruct %uint %uint %MessageRArrayType
%DiagnosticDataPtr = OpTypePointer StorageBuffer %DiagnosticData
%EntryPointType = OpTypeFunction %void

; LITERALS ;
%constant_0u = OpConstant %uint 0
%constant_1u = OpConstant %uint 1
%constant_2u = OpConstant %uint 2
%constant_3u = OpConstant %uint 3
%constant_4u = OpConstant %uint 4
%constant_ScopeDevice = OpConstant %uint 1
%constant_MemoryAccessNone = OpConstant %uint 0

; DECLARATION BLOCK ;
%var_PCData = OpVariable %BreadcrumbWriteDataPtr PushConstant
%var_DiagnosticData = OpVariable %DiagnosticDataPtr StorageBuffer

; ENTRY POINT BLOCK ;
%main = OpFunction %void None %EntryPointType
    %base_block = OpLabel
        ; SPIRV variables require pre-definitions
        %i = OpVariable %FunctionUintPtr Function

        ; Get element pointers
        %count_ptr = OpAccessChain %StorageBufferUintPtr %var_DiagnosticData %constant_0u
        %limit_ptr = OpAccessChain %StorageBufferUintPtr %var_DiagnosticData %constant_1u

        ; Limit is shared per invocation
        %limit = OpLoad %uint %limit_ptr

        ; Loop header
        OpStore %i %constant_0u

        ; Ignore the initial check
        OpBranch %loop_check
    ; /base_block

    %loop_check = OpLabel
        %i_checkload = OpLoad %uint %i
        %ilt = OpULessThan %bool %i_checkload %constant_4u
        OpLoopMerge %loop_merge %loop_continue None
        OpBranchConditional %ilt %loop_body %loop_merge
    ; /loop_check

    %loop_body = OpLabel
        %i_bodyload = OpLoad %uint %i

        ; Get pc data
        %breadcumb_message_ptr = OpAccessChain %PushConstantUintPtr %var_PCData %constant_0u %i_bodyload
        %message = OpLoad %uint %breadcumb_message_ptr

        ; Valid message?
        %valid = OpINotEqual %bool %message %constant_0u

        ; Exit the loop if an invalid message is met
        OpBranchConditional %valid %valid_branch %loop_merge

        %valid_branch = OpLabel
            ; Atomically increment the counter
            %index = OpAtomicIAdd %uint %count_ptr %constant_ScopeDevice %constant_MemoryAccessNone %constant_1u

            ; Stay within limits of the diagnostics allocation
            %capped_index = OpExtInst %uint %std450 UMin %index %limit

            ; Get message ptr
            %message_ptr = OpAccessChain %StorageBufferUintPtr %var_DiagnosticData %constant_2u %capped_index

            ; Write the breadcrumb
            OpStore %message_ptr %message
            OpBranch %loop_continue
        ; /valid_branch
    ; /loop_body

    %loop_continue = OpLabel
        ; Increment counter and check again
        %iinc = OpIAdd %uint %i_bodyload %constant_1u
        OpStore %i %iinc
        OpBranch %loop_check
    ; loop_continue

    %loop_merge = OpLabel
        OpReturn
    ; loop_merge
OpFunctionEnd
